import { useState } from 'react';
import { DndProvider } from 'react-dnd';
import { useDrop, useDrag } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import WeatherWidget from './widgets/Weather/WeatherWidget';
import { RemoveWidgetProvider } from './RemoveWidgetContext';
import TriviaWidget from './widgets/Trivia/TriviaWidget';
import NewsWidget from './widgets/News/NewsWidget';
import MoviesWidget from './widgets/Movies/MoviesWidget';
import './App.css';
import WbSunnyIcon from '@mui/icons-material/WbSunny';
import ShowChartIcon from '@mui/icons-material/ShowChart';
import LiveTvIcon from '@mui/icons-material/LiveTv';
import ArticleIcon from '@mui/icons-material/Article';
import React from 'react';

// Memoized TriviaWidget to prevent remounting unless widgetId changes
const MemoizedTriviaWidget = React.memo(function MemoizedTriviaWidget(props) {
  return <TriviaWidget {...props} />;
});

function App() {
  const [dashboardWidgets, setDashboardWidgets] = useState([]);
  const [moviesBySlot, setMoviesBySlot] = useState([null, null, null, null]);
  const [weatherBySlot, setWeatherBySlot] = useState([null, null, null, null]);
  window.dashboardWidgetsState = dashboardWidgets.filter(Boolean);
  const availableWidgets = [
    { id: 'weather', name: 'Weather', component: WeatherWidget },
    { id: 'trivia', name: 'Programming Trivia', component: TriviaWidget },
    { id: 'news', name: 'News', component: NewsWidget },
    { id: 'movies', name: 'Movies', component: MoviesWidget },
  ];

  // Add widget from sidebar
  function handleDrop(widgetId) {
    if (!dashboardWidgets.includes(widgetId)) {
      setDashboardWidgets([...dashboardWidgets, widgetId]);
    }
  }

  // Remove widget from dashboard
  function handleRemove(idx) {
    const newWidgets = [...dashboardWidgets];
    newWidgets[idx] = undefined;
    setDashboardWidgets(newWidgets);
    // Clear movie data for removed slot
    setMoviesBySlot(prev => {
      const updated = [...prev];
      updated[idx] = null;
      return updated;
    });
    // Clear weather data for removed slot
    setWeatherBySlot(prev => {
      const updated = [...prev];
      updated[idx] = null;
      return updated;
    });
  }

  // Drag-and-drop reorder logic
  function moveWidget(dragIndex, hoverIndex) {
    const updated = [...dashboardWidgets];
    const [removed] = updated.splice(dragIndex, 1);
    updated.splice(hoverIndex, 0, removed);
    setDashboardWidgets(updated);
    // Move movie data with widget
    setMoviesBySlot(prev => {
      const arr = [...prev];
      const [movie] = arr.splice(dragIndex, 1);
      arr.splice(hoverIndex, 0, movie);
      return arr;
    });
    // Move weather data with widget
    setWeatherBySlot(prev => {
      const arr = [...prev];
      const [weather] = arr.splice(dragIndex, 1);
      arr.splice(hoverIndex, 0, weather);
      return arr;
    });
  }

  return (
    <DndProvider backend={HTML5Backend}>
      <RemoveWidgetProvider onRemove={handleRemove}>
        <div className="dashboard-container">
          <aside className="sidebar">
            <h2>Dashboard</h2>
            <ul>
              {availableWidgets.map(w => (
                <SidebarWidget key={w.id} widget={w} />
              ))}
            </ul>
          </aside>
          <main className="dashboard">
            {/* <h1>My Dashboard</h1> */}
            <DashboardGrid
              dashboardWidgets={dashboardWidgets}
              availableWidgets={availableWidgets}
              moveWidget={moveWidget}
              handleRemove={handleRemove}
              handleDrop={handleDrop}
            />
          </main>
        </div>
      </RemoveWidgetProvider>
    </DndProvider>
  );
// DashboardGrid: drop target for sidebar widgets
function DashboardGrid({ dashboardWidgets, availableWidgets, moveWidget, handleRemove, handleDrop }) {
  // Track which slot is being hovered
  const [hoveredSlot, setHoveredSlot] = useState(null);
  const handleSlotEnter = idx => setHoveredSlot(idx);
  const handleSlotLeave = () => setHoveredSlot(null);

  // Always show 4 slots, fill with widgets or empty slots
  const slots = [0, 1, 2, 3].map(pos => {
    const widgetId = dashboardWidgets[pos];
    let widgetClass = '';
    let slotClass = '';
    if (pos === 0) slotClass = 'weather-slot';
    if (pos === 1) slotClass = 'trivia-slot';
    if (pos === 2) slotClass = 'movies-slot';
    if (pos === 3) slotClass = 'news-slot';
    if (widgetId === 'weather') widgetClass = 'widget weather-widget';
    else if (widgetId === 'trivia') widgetClass = 'widget trivia-widget';
    else if (widgetId === 'movies') widgetClass = 'widget movies-widget';
    else if (widgetId === 'news') widgetClass = 'widget news-widget';

    // Make each slot a drop target for any widget
    const [{ isOver }, drop] = useDrop({
      accept: 'WIDGET',
      drop: (item) => {
        if (!dashboardWidgets[pos]) {
          const newWidgets = [...dashboardWidgets];
          newWidgets[pos] = item.id;
          setDashboardWidgets(newWidgets);
          // Only set moviesBySlot[pos] to null if adding from sidebar (no item.index)
          if (item.id === 'movies' && item.index === undefined) {
            setMoviesBySlot(prev => {
              const arr = [...prev];
              arr[pos] = null;
              return arr;
            });
          }
          // Only set weatherBySlot[pos] to null if adding from sidebar (no item.index)
          if (item.id === 'weather' && item.index === undefined) {
            setWeatherBySlot(prev => {
              const arr = [...prev];
              arr[pos] = null;
              return arr;
            });
          }
        }
        return { dropped: true };
      },
      collect: monitor => ({
        isOver: monitor.isOver(),
      }),
    });

    const slotHighlightClass = isOver ? 'drag-over' : '';

    if (widgetId) {
      // Memoize widget component so it only remounts if widgetId changes
      const WidgetComponent = availableWidgets.find(w => w.id === widgetId).component;
      // Make the widget draggable to any empty slot
      const [{ isDragging }, drag] = useDrag({
        type: 'DASHBOARD_WIDGET',
        item: { index: pos, id: widgetId },
        collect: monitor => ({ isDragging: monitor.isDragging() }),
      });
      return (
        <DraggableWidgetCard
          key={widgetId + '-' + pos}
          index={pos}
          moveWidget={moveWidget}
          onRemove={() => handleRemove(pos)}
        >
          <RemoveWidgetProvider onRemove={handleRemove} index={pos}>
            <div ref={node => { drop(node); drag(node); }} className={slotClass + ' ' + widgetClass + ' ' + slotHighlightClass + (isDragging ? ' dragging' : '')}>
              {widgetId === 'movies' ? (
                <MoviesWidget
                  movie={moviesBySlot[pos]}
                  setMovie={movie => {
                    setMoviesBySlot(prev => {
                      const arr = [...prev];
                      arr[pos] = movie;
                      return arr;
                    });
                  }}
                />
              ) : widgetId === 'weather' ? (
                <WeatherWidget
                  weather={weatherBySlot[pos]}
                  setWeather={weather => {
                    setWeatherBySlot(prev => {
                      const arr = [...prev];
                      arr[pos] = weather;
                      return arr;
                    });
                  }}
                />
              ) : widgetId === 'trivia' ? (
                <MemoizedTriviaWidget index={pos} />
              ) : (
                <WidgetComponent />
              )}
            </div>
          </RemoveWidgetProvider>
        </DraggableWidgetCard>
      );
    } else {
      // Accept drop from sidebar or from another slot
      const [{ isOver }, dropEmpty] = useDrop({
        accept: ['WIDGET', 'DASHBOARD_WIDGET'],
        drop: (item) => {
          if (!dashboardWidgets[pos]) {
            const newWidgets = [...dashboardWidgets];
            // If dragging from another slot, remove from old slot
            if (item.index !== undefined) {
              newWidgets[item.index] = undefined;
              // Move movie data with widget if it's a MovieWidget
              if (item.id === 'movies') {
                setMoviesBySlot(prev => {
                  const arr = [...prev];
                  const [movie] = arr.splice(item.index, 1);
                  arr.splice(pos, 0, movie);
                  return arr;
                });
              }
              // Move weather data with widget if it's a WeatherWidget
              if (item.id === 'weather') {
                setWeatherBySlot(prev => {
                  const arr = [...prev];
                  const [weather] = arr.splice(item.index, 1);
                  arr.splice(pos, 0, weather);
                  return arr;
                });
              }
            }
            newWidgets[pos] = item.id;
            setDashboardWidgets(newWidgets);
          }
          return { dropped: true };
        },
        collect: monitor => ({
          isOver: monitor.isOver(),
        }),
      });
      const slotHighlightClassEmpty = isOver ? 'drag-over' : '';
      return (
        <div
          key={pos}
          ref={dropEmpty}
          className={slotClass + ' ' + slotHighlightClassEmpty}
        >
          <div className="empty"></div>
        </div>
      );
    }
  });

  return (
    <div className="dashboard-grid">
      {slots}
    </div>
  );
}
}

// SidebarWidget: draggable widget icon
function SidebarWidget({ widget }) {
  // Disable drag if widget is already in dashboardWidgets
  // Only disable drag if widget is present in a slot (not undefined)
  const appState = window.dashboardWidgetsState || [];
  const isDisabled = appState.some(id => id === widget.id);
  const [{ isDragging }, drag] = useDrag(() => ({
    type: 'WIDGET',
    item: { id: widget.id },
    canDrag: !isDisabled,
    collect: monitor => ({
      isDragging: monitor.isDragging(),
    }),
  }));

  let IconComponent;
  let tooltip = '';
  switch (widget.id) {
    case 'weather':
      IconComponent = WbSunnyIcon;
      tooltip = 'Weather';
      break;
    case 'trivia':
      IconComponent = ShowChartIcon;
      tooltip = 'Programming Trivia';
      break;
    case 'movies':
      IconComponent = LiveTvIcon;
      tooltip = 'Movies';
      break;
    case 'news':
      IconComponent = ArticleIcon;
      tooltip = 'News';
      break;
    default:
      IconComponent = null;
      tooltip = widget.name;
  }

  return (
    <li
      ref={drag}
      className={`sidebar-widget${isDragging ? ' dragging' : ''}${isDisabled ? ' disabled' : ''}`}
      style={{ opacity: isDisabled ? 0.5 : 1, pointerEvents: isDisabled ? 'none' : 'auto', display: 'flex', alignItems: 'center', justifyContent: 'center', height: '48px' }}
      title={tooltip}
    >
      {IconComponent && <IconComponent fontSize="large" style={{ margin: '0 8px' }} />}
    </li>
  );
}

// DraggableWidgetCard: dashboard widget card that can be reordered and removed
import { useRef } from 'react';
function DraggableWidgetCard({ children, index, moveWidget, onRemove }) {
  const ref = useRef(null);
  const [{ handlerId }, drop] = useDrop({
    accept: 'DASHBOARD_WIDGET',
    collect: monitor => ({ handlerId: monitor.getHandlerId() }),
    hover(item, monitor) {
      if (!ref.current) return;
      const dragIndex = item.index;
      const hoverIndex = index;
      if (dragIndex === hoverIndex) return;
      moveWidget(dragIndex, hoverIndex);
      item.index = hoverIndex;
    },
  });
  const [{ isDragging }, drag] = useDrag({
    type: 'DASHBOARD_WIDGET',
    item: { index },
    collect: monitor => ({ isDragging: monitor.isDragging() }),
  });
  drag(drop(ref));
  return (
    <div ref={ref} className={`dashboard-card${isDragging ? ' dragging' : ''}`} data-handler-id={handlerId}>
      {children}
    </div>
  );
}

export default App;
